<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Змейка с плотными блоками</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: monospace;
        }
        
        canvas {
            border: 2px solid #333;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="600" height="600"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Размер игрового поля (в клетках)
        const gridSize = 20;
        const gridWidth = canvas.width / gridSize;
        const gridHeight = canvas.height / gridSize;
        
        // Цвета змейки (два оттенка зеленого, чередующиеся)
        const snakeColor1 = '#0a5a0a';    // Темно-зеленый
        const snakeColor2 = '#0f9a0f';    // Светло-зеленый
        const appleColor = '#ff0000';     // Красный для яблок
        
        // Игровые переменные
        let snake = [];
        let apple = {x: 0, y: 0};
        let direction = {x: 1, y: 0};
        let nextDirection = {x: 1, y: 0};
        let gameSpeed = 120;
        let gameRunning = true;
        let gameLoop;
        let moveCounter = 0;
        let score = 0;
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let visitedCells = new Set();
        let path = [];
        
        // Инициализация игры
        function initGame() {
            // Создаем змейку с начальной длиной 4
            snake = [
                {x: 10, y: 10},
                {x: 9, y: 10},
                {x: 8, y: 10},
                {x: 7, y: 10}
            ];
            
            // Сброс данных для ИИ
            visitedCells.clear();
            path = [];
            
            // Генерируем первое яблоко
            generateApple();
            
            // Сброс направления
            direction = {x: 1, y: 0};
            nextDirection = {x: 1, y: 0};
            
            moveCounter = 0;
            score = 0;
        }
        
        // Генерация нового яблока
        function generateApple() {
            let newApple;
            let appleOnSnake;
            
            do {
                appleOnSnake = false;
                newApple = {
                    x: Math.floor(Math.random() * gridWidth),
                    y: Math.floor(Math.random() * gridHeight)
                };
                
                // Проверяем, не появилось ли яблоко на змейке
                for (let segment of snake) {
                    if (segment.x === newApple.x && segment.y === newApple.y) {
                        appleOnSnake = true;
                        break;
                    }
                }
            } while (appleOnSnake);
            
            apple = newApple;
            
            // Пересчитываем путь при появлении нового яблока
            calculatePathToApple();
        }
        
        // Улучшенный ИИ: алгоритм A* для поиска пути
        function calculatePathToApple() {
            const head = snake[0];
            const target = apple;
            
            // Если яблоко на той же клетке, путь пустой
            if (head.x === target.x && head.y === target.y) {
                path = [];
                return;
            }
            
            // Создаем сет для хранения препятствий (тело змейки, кроме хвоста)
            const obstacles = new Set();
            for (let i = 1; i < snake.length; i++) {
                obstacles.add(`${snake[i].x},${snake[i].y}`);
            }
            
            // Реализация A* алгоритма
            const openSet = new Set();
            const closedSet = new Set();
            const gScore = new Map();
            const fScore = new Map();
            const cameFrom = new Map();
            
            const startKey = `${head.x},${head.y}`;
            const targetKey = `${target.x},${target.y}`;
            
            openSet.add(startKey);
            gScore.set(startKey, 0);
            fScore.set(startKey, heuristic(head, target));
            
            while (openSet.size > 0) {
                // Находим узел с наименьшим fScore
                let currentKey = null;
                let lowestF = Infinity;
                for (const key of openSet) {
                    const f = fScore.get(key) || Infinity;
                    if (f < lowestF) {
                        lowestF = f;
                        currentKey = key;
                    }
                }
                
                // Если достигли цели
                if (currentKey === targetKey) {
                    path = reconstructPath(cameFrom, currentKey, head);
                    return;
                }
                
                openSet.delete(currentKey);
                closedSet.add(currentKey);
                
                const [cx, cy] = currentKey.split(',').map(Number);
                
                // Проверяем соседние клетки
                const neighbors = [
                    {x: cx + 1, y: cy},
                    {x: cx - 1, y: cy},
                    {x: cx, y: cy + 1},
                    {x: cx, y: cy - 1}
                ];
                
                for (const neighbor of neighbors) {
                    const neighborKey = `${neighbor.x},${neighbor.y}`;
                    
                    // Проверяем границы и препятствия
                    if (neighbor.x < 0 || neighbor.x >= gridWidth || 
                        neighbor.y < 0 || neighbor.y >= gridHeight ||
                        obstacles.has(neighborKey)) {
                        continue;
                    }
                    
                    if (closedSet.has(neighborKey)) continue;
                    
                    // Вычисляем стоимость пути
                    const tentativeG = (gScore.get(currentKey) || 0) + 1;
                    
                    if (!openSet.has(neighborKey)) {
                        openSet.add(neighborKey);
                    } else if (tentativeG >= (gScore.get(neighborKey) || Infinity)) {
                        continue;
                    }
                    
                    cameFrom.set(neighborKey, currentKey);
                    gScore.set(neighborKey, tentativeG);
                    fScore.set(neighborKey, tentativeG + heuristic(neighbor, target));
                }
            }
            
            // Если путь не найден, используем запасную стратегию
            path = [];
        }
        
        // Эвристика для A* (манхэттенское расстояние)
        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }
        
        // Восстановление пути
        function reconstructPath(cameFrom, currentKey, head) {
            const totalPath = [];
            let current = currentKey;
            
            while (cameFrom.has(current)) {
                totalPath.unshift(current);
                current = cameFrom.get(current);
            }
            
            // Преобразуем ключи обратно в координаты
            const result = totalPath.map(key => {
                const [x, y] = key.split(',').map(Number);
                return {x, y};
            });
            
            return result;
        }
        
        // Улучшенная логика ИИ для выбора направления
        function calculateBotDirection() {
            const head = snake[0];
            
            // Если есть вычисленный путь, следуем ему
            if (path.length > 0) {
                const nextStep = path[0];
                const dx = nextStep.x - head.x;
                const dy = nextStep.y - head.y;
                
                // Удаляем пройденный шаг из пути
                path.shift();
                
                // Возвращаем направление к следующему шагу
                return {x: dx, y: dy};
            }
            
            // Если путь не найден, используем запасную стратегию
            
            // 1. Пробуем двигаться к яблоку
            const dxToApple = apple.x - head.x;
            const dyToApple = apple.y - head.y;
            
            // Предпочитаем горизонтальное движение, если оно эффективнее
            if (Math.abs(dxToApple) >= Math.abs(dyToApple)) {
                if (dxToApple > 0 && isDirectionSafe({x: 1, y: 0})) {
                    return {x: 1, y: 0};
                } else if (dxToApple < 0 && isDirectionSafe({x: -1, y: 0})) {
                    return {x: -1, y: 0};
                }
            }
            
            // 2. Пробуем вертикальное движение
            if (dyToApple > 0 && isDirectionSafe({x: 0, y: 1})) {
                return {x: 0, y: 1};
            } else if (dyToApple < 0 && isDirectionSafe({x: 0, y: -1})) {
                return {x: 0, y: -1};
            }
            
            // 3. Стратегия избегания тупиков (обход по периметру)
            const directions = [
                {x: 1, y: 0},   // вправо
                {x: 0, y: 1},   // вниз
                {x: -1, y: 0},  // влево
                {x: 0, y: -1}   // вверх
            ];
            
            // Оцениваем каждое направление по нескольким критериям
            let bestDirection = null;
            let bestScore = -Infinity;
            
            for (const dir of directions) {
                if (!isDirectionSafe(dir)) continue;
                
                const newHead = {x: head.x + dir.x, y: head.y + dir.y};
                
                // Вычисляем оценку для этого направления
                let score = 0;
                
                // 1. Расстояние до яблока (чем меньше, тем лучше)
                const distanceToApple = Math.abs(newHead.x - apple.x) + Math.abs(newHead.y - apple.y);
                score += (gridWidth + gridHeight - distanceToApple) * 3;
                
                // 2. Свободное пространство вокруг
                const freeSpace = countFreeSpace(newHead);
                score += freeSpace * 2;
                
                // 3. Избегаем краев (предпочитаем центр)
                const centerX = gridWidth / 2;
                const centerY = gridHeight / 2;
                const distanceToCenter = Math.abs(newHead.x - centerX) + Math.abs(newHead.y - centerY);
                score += (gridWidth + gridHeight - distanceToCenter);
                
                // 4. Направление от тупиков (не идем в клетки с 1 выходом)
                if (hasOnlyOneExit(newHead)) {
                    score -= 50;
                }
                
                if (score > bestScore) {
                    bestScore = score;
                    bestDirection = dir;
                }
            }
            
            if (bestDirection) {
                return bestDirection;
            }
            
            // 4. Последний шанс: любое безопасное направление
            for (const dir of directions) {
                if (isDirectionSafe(dir)) {
                    return dir;
                }
            }
            
            // 5. Если все направления опасны, продолжаем текущее (надеемся на лучшее)
            return direction;
        }
        
        // Проверка безопасности направления
        function isDirectionSafe(dir) {
            const head = snake[0];
            const newHead = {
                x: head.x + dir.x,
                y: head.y + dir.y
            };
            
            // Проверяем, не выйдет ли змейка за границы
            if (newHead.x < 0 || newHead.x >= gridWidth || newHead.y < 0 || newHead.y >= gridHeight) {
                return false;
            }
            
            // Проверяем, не столкнется ли змейка с собой
            // Проверяем все сегменты, кроме хвоста (он может сдвинуться)
            for (let i = 0; i < snake.length - 1; i++) {
                if (snake[i].x === newHead.x && snake[i].y === newHead.y) {
                    return false;
                }
            }
            
            return true;
        }
        
        // Подсчет свободного пространства вокруг клетки
        function countFreeSpace(cell) {
            let freeCount = 0;
            const directions = [
                {x: 1, y: 0},
                {x: -1, y: 0},
                {x: 0, y: 1},
                {x: 0, y: -1}
            ];
            
            for (const dir of directions) {
                const newCell = {x: cell.x + dir.x, y: cell.y + dir.y};
                
                // Проверяем границы
                if (newCell.x < 0 || newCell.x >= gridWidth || 
                    newCell.y < 0 || newCell.y >= gridHeight) {
                    continue;
                }
                
                // Проверяем, не занята ли клетка телом
                let occupied = false;
                for (const segment of snake) {
                    if (segment.x === newCell.x && segment.y === newCell.y) {
                        occupied = true;
                        break;
                    }
                }
                
                if (!occupied) {
                    freeCount++;
                }
            }
            
            return freeCount;
        }
        
        // Проверка, имеет ли клетка только один выход
        function hasOnlyOneExit(cell) {
            return countFreeSpace(cell) <= 1;
        }
        
        // Обновление игрового состояния
        function updateGame() {
            moveCounter++;
            
            // Каждые 3 хода пересчитываем путь (оптимизация производительности)
            if (moveCounter % 3 === 0 || path.length === 0) {
                calculatePathToApple();
            }
            
            // Определяем следующее направление
            nextDirection = calculateBotDirection();
            
            // Обновляем направление движения
            direction = nextDirection;
            
            // Получаем новую позицию головы
            const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};
            
            // Проверяем столкновение с границами
            if (head.x < 0 || head.x >= gridWidth || head.y < 0 || head.y >= gridHeight) {
                resetGame();
                return;
            }
            
            // Проверяем столкновение с собой
            for (let segment of snake) {
                if (segment.x === head.x && segment.y === head.y) {
                    resetGame();
                    return;
                }
            }
            
            // Добавляем новую голову
            snake.unshift(head);
            
            // Проверяем, съела ли змейка яблоко
            if (head.x === apple.x && head.y === apple.y) {
                score += 10;
                
                // Увеличиваем сложность
                if (score % 50 === 0 && gameSpeed > 60) {
                    gameSpeed -= 5;
                    stopGame();
                    startGame();
                }
                
                // Генерируем новое яблоко
                generateApple();
                
                // Обновляем рекорд
                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('snakeHighScore', highScore);
                }
            } else {
                // Если яблоко не съедено, удаляем хвост
                snake.pop();
            }
            
            // Рисуем игру
            drawGame();
        }
        
        // Отрисовка игры с плотными блоками
        function drawGame() {
            // Очистка canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Отрисовка змейки с плотными блоками и чередующимися цветами
            for (let i = 0; i < snake.length; i++) {
                const segment = snake[i];
                
                // Чередование цветов: четные индексы - цвет 1, нечетные - цвет 2
                ctx.fillStyle = (i % 2 === 0) ? snakeColor1 : snakeColor2;
                
                // Рисуем плотный квадрат БЕЗ промежутков
                // Убираем -1 и рисуем полный размер ячейки
                ctx.fillRect(
                    segment.x * gridSize, 
                    segment.y * gridSize, 
                    gridSize, 
                    gridSize
                );
            }
            
            // Отрисовка яблока (плотный красный квадрат)
            ctx.fillStyle = appleColor;
            ctx.fillRect(
                apple.x * gridSize, 
                apple.y * gridSize, 
                gridSize, 
                gridSize
            );
        }
        
        // Сброс игры
        function resetGame() {
            stopGame();
            initGame();
            drawGame();
            startGame();
        }
        
        // Запуск игрового цикла
        function startGame() {
            gameRunning = true;
            gameLoop = setInterval(updateGame, gameSpeed);
        }
        
        // Остановка игры
        function stopGame() {
            gameRunning = false;
            if (gameLoop) {
                clearInterval(gameLoop);
            }
        }
        
        // Инициализация и запуск игры при загрузке страницы
        window.addEventListener('load', () => {
            initGame();
            drawGame();
            startGame();
        });
        
        // Обработка нажатия клавиш для тестирования
        document.addEventListener('keydown', (event) => {
            switch (event.key) {
                case 'ArrowUp':
                    if (direction.y === 0) nextDirection = {x: 0, y: -1};
                    break;
                case 'ArrowDown':
                    if (direction.y === 0) nextDirection = {x: 0, y: 1};
                    break;
                case 'ArrowLeft':
                    if (direction.x === 0) nextDirection = {x: -1, y: 0};
                    break;
                case 'ArrowRight':
                    if (direction.x === 0) nextDirection = {x: 1, y: 0};
                    break;
                case 'r':
                case 'R':
                    resetGame();
                    break;
                case ' ':
                    if (gameRunning) {
                        stopGame();
                    } else {
                        startGame();
                    }
                    break;
            }
        });
    </script>
</body>
</html>